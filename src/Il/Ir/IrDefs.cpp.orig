#include "precomp.h"
// @(#)$Id$
//
// Evita Il - IR (Intermediate Representation)
//
// Copyright (C) 2010 by Project Vogue.
// Written by Yoshifumi "VOGUE" INOUE. (yosi@msn.com)

//#include "./IrDefs.h"

#include "./Name.h"
#include "./Operands.h"

#include "../../Om.h"

namespace Il {
namespace Ir {

#define DEFCLASS(mp_mod, mp_outer, mp_name, ...) \
    DEFTYPE(Class, mp_mod, mp_outer, mp_name, __VA_ARGS__)

#define DEFGENERIC_CLASS_1(mp_mod, mp_outer, mp_name, mp_ty1, ...) \
    DEFTYPE(GenericClass, mp_mod, mp_outer, mp_name, __VA_ARGS__)

#define DEFTYPE(mp_mc, mp_mod, mp_outer, mp_name, ...) \
    const Name* Q_ ## mp_name; \
    mp_mc* Ty_ ## mp_name;

#include "./Types.inc"

BoolOutput* False;
BoolOutput* True;
VoidOutput* Useless;
VoidOutput* Void;

#define DEFSYMBOL(name) const Name* Q_## name;
#include "./Symbols.inc"

const Name* QD_cctor;
const Name* QD_ctor;
const Name* QD_value;

Type* Ty_Bool;
const Type* Ty_VoidPtr;

#define Q(mp_name) Name::Intern(# mp_name)

namespace {
static Collection_<const Class*> ComputeBaseSpecs() {
  return CollectionV_<const Class*>();
}

static Collection_<const Class*> ComputeBaseSpecs(Class& a) {
  return CollectionV_<const Class*>(&a);
}

static Collection_<const Class*> ComputeBaseSpecs(Class& a, Class& b) {
  ASSERT(b.IsInterface());
  return CollectionV_<const Class*>(&a, &b);
}

static Collection_<const Class*> ComputeBaseSpecs(Class& a, Class& b,
                                                  Class& c) {
  ASSERT(b.IsInterface());
  ASSERT(c.IsInterface());
  return CollectionV_<const Class*>(&a, &b, &c);
}

static Collection_<const Class*> ComputeBaseSpecs(Class& a, Class& b,
                                                  Class& c, Class& d) {
  ASSERT(b.IsInterface());
  ASSERT(c.IsInterface());
  ASSERT(d.IsInterface());
  return CollectionV_<const Class*>(&a, &b, &c, &d);
}

static Collection_<const Class*> ComputeBaseSpecs(Class& a, Class& b,
                                                  Class& c, Class& d,
                                                  Class& e) {
  ASSERT(b.IsInterface());
  ASSERT(c.IsInterface());
  ASSERT(d.IsInterface());
  ASSERT(e.IsInterface());
  return CollectionV_<const Class*>(&a, &b, &c, &d, &e);
}

static Collection_<const Class*> ComputeBaseSpecs(Class& a, Class& b,
                                                  Class& c, Class& d,
                                                  Class& e, Class& f) {
  ASSERT(b.IsInterface());
  ASSERT(c.IsInterface());
  ASSERT(d.IsInterface());
  ASSERT(e.IsInterface());
  ASSERT(f.IsInterface());
  return CollectionV_<const Class*>(&a, &b, &c, &d, &e, &f);
}

static Class& Comparable_(Type& tyarg) {
  return *Ty_Comparable->Construct(tyarg).StaticCast<Class>();
}

static Class& Enumerable_(Type& tyarg) {
  return *Ty_Enumerable->Construct(tyarg).StaticCast<Class>();
}

static void InstallPropertyGet(
    Class& clazz,
    int const modifiers,
    const Type& type,
    const Name& name) {
  auto& property = *new Property(clazz, modifiers, type, name);
  clazz.AddMember(property);
  auto& method_group = *new MethodGroup(
      clazz,
      Name::Intern(String::Format("get_%s", name)));
  clazz.AddMember(method_group);
  auto& method = *new Method(
      method_group,
      modifiers | Modifier_SpecialName,
      FunctionType::Intern(type, ValuesType::Intern()));
  method_group.Add(method);
  property.Add(Q(get), method);
}

} // namespace

void Init() {
  Name::Init();

  #define DEFSYMBOL(name) Q_ ## name = &Q(name);

  #define DEFOPERATORSYMBOL(name, text) \
      Q_operator_ ## name = &Name::Intern("operator " text);

  #include "./Symbols.inc"

  QD_cctor = &Q(.cctor);
  QD_ctor = &Q(.ctor);
  QD_value = &Q(.value);

  Namespace::Global = &Namespace::CreateGlobalNamespace();
  Namespace::Common = new Namespace(*Namespace::Global, Q(Common));

  ASSERT(Ty_Object == nullptr);

  //#define Common Namespace::Common
  #define Abstract Modifier_Abstract
  #define Interface Modifier_ClassVariation_Interface
  #define Public Modifier_Public
  #define Final Modifier_Final
  #define Static Modifier_Static
  #define Ty_Common Namespace::Common
  #define Virtual Modifier_Virtual

  {
    #define DEFPRIMITIVE_TYPE(mp_name, mp_rc, mp_size, m_sign) \
        Q_ ## mp_name = &Q(mp_name); \
        Ty_ ## mp_name = new PrimitiveType( \
            *Q_ ## mp_name, \
            RegClass_ ## mp_rc, \
            mp_size, \
            m_sign);

    #define DEFTYPE(mp_mc, mp_mod, mp_outer, mp_name, ...) { \
        Q_ ## mp_name = &Q(mp_name); \
        Ty_ ## mp_name = new mp_mc( \
            *Ty_ ## mp_outer, \
            mp_mod, \
            *Q_ ## mp_name); \
        Ty_ ## mp_name->RealizeClass(ComputeBaseSpecs(__VA_ARGS__)); \
    } // DEFTYPE

    #define DEFGENERIC_CLASS_1(mp_mod, mp_outer, mp_name, mp_T, ...) { \
        Q_ ## mp_name = &Q(mp_name); \
        auto& mp_T = *new TypeParam(Q(mp_T)); \
        Ty_ ## mp_name = new GenericClass( \
            *Ty_ ## mp_outer, \
            mp_mod, \
            *Q_ ## mp_name, \
            CollectionV_<const TypeParam*>(&mp_T)); \
        Ty_ ## mp_name->RealizeClass(ComputeBaseSpecs(__VA_ARGS__)); \
    } // DEFGENERIC_CLASS

    #include "./Types.inc"

    ASSERT(Ty_Object->GetNamespace() == Namespace::Common);
  }

  auto const Ty_Values_Void = &ValuesType::Intern();

  #define Ty_ARRAY_(elemty) &ArrayType::Intern(*elemty)

  #define DEFFIELD(mp_class, mp_mod, mp_ty, mp_name) { \
      auto const pField = new Field( \
          *pClass, mp_mod, *Ty_ ## mp_ty, Q(mp_name)); \
      pClass->AddMember(*pField); \
  } // DEFFFIELD

  #define DEFGENERIC_CLASS_1(mp_mod, mp_outer, mp_name, mp_T, ...) { \
      auto const pClass = Ty_ ## mp_name; \
      auto const Ty_ ## mp_T = pClass \
          ->Find(Q(mp_T)) \
          ->StaticCast<Type>(); \
      ASSERT(Ty_ ## mp_T != nullptr);

  #define DEFMETHODGROUP(mp_class, mp_name) { \
      auto const pClass = Ty_ ## mp_class; \
      auto const pMethodGroup = new MethodGroup(*pClass, Q(mp_name)); \
      pClass->AddMember(*pMethodGroup);

  #define DEFMETHOD_0(mp_mod, mp_rety) { \
      auto const pMethod = new Method(*pMethodGroup, mp_mod, \
          FunctionType::Intern( \
              *Ty_ ## mp_rety, \
              *Ty_Values_Void)); \
      pMethodGroup->Add(*pMethod); \
  } // DEFMETHOD_0

  #define DEFMETHOD_1(mp_mod, mp_rety, mp_ty1, mp_nm1) { \
      auto const pMethod = new Method(*pMethodGroup, mp_mod, \
          FunctionType::Intern( \
              *Ty_ ## mp_rety, \
              ValuesType::Intern(*Ty_ ## mp_ty1))); \
      pMethod->SetParamName(0, Q(mp_nm1)); \
      pMethodGroup->Add(*pMethod); \
  } // DEFMETHOD_1

  #define DEFMETHOD_2(mp_mod, mp_rety, mp_ty1, mp_nm1, mp_ty2, mp_nm2) { \
      auto const pMethod = new Method(*pMethodGroup, mp_mod, \
          FunctionType::Intern( \
              *Ty_ ## mp_rety, \
              ValuesType::Intern( \
                  *Ty_ ## mp_ty1, \
                  *Ty_ ## mp_ty2))); \
      pMethod->SetParamName(0, Q(mp_nm1)); \
      pMethod->SetParamName(1, Q(mp_nm2)); \
      pMethodGroup->Add(*pMethod); \
  } // DEFMETHOD_1

  #define ENDGENERIC_CLASS(mp_name) }
  #define ENDMETHODGROUP(mp_class, mp_name) }

  #define DEFPROPERTY_GET(mp_class, mp_mod, mp_ty, mp_name) \
    InstallPropertyGet(*Ty_ ## mp_class, mp_mod, *Ty_ ## mp_ty, Q(mp_name));

  #define DEFTYPE(mp_mc, mp_mod, mp_outer, mp_name, ...)

  class Local {
    public: static Type* ConstructClass(Class* clazz, Type* tyarg1) {
      return &static_cast<GenericClass*>(clazz)->Construct(*tyarg1);
    }
  };

  #define Ty_ArrayType ArrayType
  #define Ty_Enumerator_T Local::ConstructClass(Ty_Enumerator, Ty_T)

  #include "./Types.inc"

  Ty_Bool = new BoolType();
  Ty_VoidPtr = &PointerType::Intern(*Ty_Void);

  // Well known constant operand.
  False = new BoolOutput();
  True = new BoolOutput();
  Useless = new VoidOutput();
  Void = new VoidOutput();

  // Set name to special outputs for FASL.
  False->set_name(1);
  True->set_name(2);
  Void->set_name(3);
}

} // Ir
} // Il
